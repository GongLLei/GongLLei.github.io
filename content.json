[{"title":"前后端接口规范简要记录","date":"2017-06-10T14:25:14.000Z","path":"2017/06/10/前后端接口规范简要记录/","text":"前后端分离的开发模式当中，关于接口方面的开发调试会占据相当大的比例，因此接口规则的约定以及接口文档的规范性还是十分重要的，以前的在实验室的项目中在这方面做得就不太好。最近实验室要开一个新的项目，在项目开始前也思考了一下这个问题并就自己目前的了解定义了一些简单的规则，在这边也做一下纪录。 接口说明 1.前后端接口命名方式为驼峰式，例如userName，getFormData等等。 2.默认情况下前端请求数据的content－type设置为Content-Type：application/x-www-form-urlencoded，方便后端直接拿到请求值 3.后端返回数据必须包含status项，以方便前端判断。具体采用如下格式：12345678910&#123; data:&#123; //项目中实际的返回数据用data包裹 &#125; status:｛ code:0, msg:'登陆成功' &#125;&#125; 其中，data与status同级别，项目中实际返回的数据用data包裹，如果不需要返回数据则只返回status，说明此次请求的结果是怎么样的。status由code和msg组成，code为自定义的返回码，一般默认0为相关请求成功，其余的码由前后端根据业务商定；msg为对于状态码的相关说明，如操作失败，操作成功，查询成功等等等。 4.对于每一个请求，前端在拿到请求数据之后首先判断status再做后续业务相关的操作。 5.每一个借口均需要生成借口文档 下面我们举一个接口文档的例子 登陆模块请求 请求说明：用户登录 method:‘POST’ Content-Type：application/x-www-form-urlencoded url:/user/login 参数 说明 是否必须 默认值 类型 userName 用户名 是 无 string password 密码 是 无 string 请求示例1234&#123; userName:&apos;gonglei&apos;, password:&apos;123456&apos;&#125; 响应示例12345678&#123;//因为不需要data项故只返回status即可。 status:｛ code:0, msg:&apos;登陆成功&apos; &#125;&#125;","tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://yoursite.com/tags/编程规范/"}]},{"title":"Web IDE之Terminal组件开发","date":"2017-05-22T07:41:42.000Z","path":"2017/05/22/Web-IDE之Terminal组件开发/","text":"&nbsp;&nbsp;&nbsp;&nbsp;随着web技术的发展，越来越多的客户端的程序正逐渐搬到了浏览器上面。比如web端的IDE，web端的一些团队管理工具如teambition等。然后挺久之前在知乎上看到过coding的架构师写的一篇关于Web IDE实现的答案，很感兴趣，一直想有所尝试。正巧组上最近在开发一款公司内部使用的WebIDE项目，主要负责其中的terminal组件开发。我和大多数的开发者是一样的，每天都在高频率的使用terminal，但是对于其实现的原理却不了解。经过上周的一些搜索和实践，最终搞清了它的原理，并写了一个demo出来。现在记录一下上周的一些学习和实践的历程。 1.Terminal原理 &nbsp;&nbsp;&nbsp;&nbsp;首先应该了解的是Terminal，bash和shell之间的区别。我们通常所说的Terminal是指的终端模拟器，比如mac上自带的terminal.app和更常用的item2等，它们都是直面用户的gui程序。然后shell是命令行解释器，它的职责是执行终端设备传递过来的字符串和控制字符，执行相应的命令，通俗点讲，就是接受用户命令，调用相关应用程序。而bash是shell中的一种，其它还有功能更强大的如zsh等等。 &nbsp;&nbsp;&nbsp;&nbsp;一般情况下终端模拟器是不会直接与shell通讯的，而是通过pty（Pseudoterminal，伪终端）来实现。pty 是一对 master-slave 设备，master 设备表现得像一个文件，slave 设备表现得像一个终端设备。终端模拟器通过文件读写流与 pyt master通讯，pty master再将字符输入经过线路规程的转换传送给nty slave，slave进一步传递给bash。整个过程大概如下：1终端模拟器(item2,terminal.app等) ——&gt; nty master ——&gt; nty slave ——&gt; shell(bash,zsh等) 这样shell就能接收到用户的输入并执行相应的命令了。 2.Web Terminal的实现原理&nbsp;&nbsp;&nbsp;&nbsp;理解了terminal的原理之后，对于在web端的实现仍然没有什么头绪，直到看到coding 总结的一副原理图才有了一些想法，在这里引用一下：通过上面的图可以看出，整个terminal组件从前端到后台的实现当中，大概要做一下几个东西： 在浏览器端实现的终端模拟器(前端) 前后端建立WebSocket连接，保证用户的输入能够实时推送到后端和后端的反馈相应到前端(协议) 后端创建pty对，来与终端模拟器以及shell通讯(后端) 下面会针对以上三个部分描述一下详细的实现。 3.Web Terminal的具体实现&nbsp;&nbsp;&nbsp;&nbsp;首先说一下，整个IDE项目前端使用的React全家桶，后端使用的是express，做一下说明，下面出现的代码就比较容易理解了。整体的思路就是，在组件加载后（此时并未生成terminal实例），前端首先实例化一个终端模拟器。然后请求后端生成一个pty对，后端生成 pty对后，将标识其唯一性的pty id返回给前端用以socket连接，前端拿到pty id之后与后端建立socket连接，实现实时的通讯，剩下的就是处理一些具体的操作，下面将从前端和后台两个方面进行介绍。 3.1 前端实现&nbsp;&nbsp;&nbsp;&nbsp;先说一下终端模拟器，这一方面来讲，目前有很多成熟的轮子可以直接使用，考察了一下最终选择了xterm.js这个库，原因是上手比较简单，虽然它只有demo没有文档，23333，但是看官方的demo已经足够了解了。生成终端模拟器之后与后端建立socket连接即可，贴一下部分的主要代码： 1234567891011121314151617181920212223242526import Xterm from 'xterm';import 'xterm/lib/addons/fit/fit.js';import 'xterm/lib/xterm.css';import 'xterm/lib/addons/attach/attach'; //引入相关库const &#123; pid &#125; = this.props.terminalData; //组件渲染后拿到后端声称的pty 的id，标识每一个pty对，主要为建立WebScoket连接时使用。const terminalContainer = this.terminal;const terminal = new Xterm(&#123; //生成一个Xterm类的实例 cursorBlink: true, scrollBack: 3, tabStopWidth: 3,&#125;);terminal.open(terminalContainer); //terminalContainer作为终端模拟器的容器 terminal.fit();const socketUrl = `ws://localhost:1234/terminals/$&#123;pid&#125;`;//建立socket连接的地址，注意协议为wsconst socket = new WebSocket(socketUrl); //创建WebSocketsocket.onopen = () =&gt; &#123; terminal.attach(socket); your code ...&#125;; socket.onclose = () =&gt; &#123; message.error('与服务端连接已断开'); your code ...&#125;;socket.onerror = ()=&gt;&#123; your code ...&#125; 3.2 后端实现待续…","tags":[{"name":"Web IDE","slug":"Web-IDE","permalink":"http://yoursite.com/tags/Web-IDE/"},{"name":"Javascript","slug":"Javascript","permalink":"http://yoursite.com/tags/Javascript/"},{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}]},{"title":"正则入门","date":"2017-05-12T08:32:21.000Z","path":"2017/05/12/正则入门/","text":"&nbsp;&nbsp;&nbsp;&nbsp;正则表达式在前端开发当中还是很常用的，它可以帮助我们完成一些复杂字符串的匹配，搜索和替换工作，比如说 验证邮箱格式，验证手机号码以及其他一些更高级的应用。当然作为一个前端渣，只是用正则来解决一些业务上的问题，并没有过更高级的应用 －－！写这篇文章的主要目的也只是记录一下正则的常用语法，这样以后有遗忘的时候就不用到处找地方查了 －－！ 以下是一些常用的元字符和搭配： ^: 匹配字符串的开始 $: 匹配字符串的结束 .: 匹配除了换行符之外的任何字符 \\w: 匹配字母或者数组或者下划线或者汉字。\\W(w字母大写)表示其反义，即匹配任意不是字母，数字，下划线，汉字的字符 \\b: 匹配单词的开头和结尾，即单词的分界处。\\B表示其反义 \\d: 匹配一个数字,\\d{2}匹配两个数字，\\d{2,5}匹配2个到5个数字。\\D表示其反义 \\s: 匹配任意的空白符，包括空格，制表符，换行符等。\\S表示其反义 *: 代表数量，指定＊前面的内容可以连续重复的使用任意次数(零次或者更多次)来使表达式匹配，和.连用即 .＊的时候,表示任意数量的不包含换行的字符 +:代表数量，表示重复一次或者更多次 ？：代表数量，表示重复零次或者一次 {n}:代表数量，表示重复n次 {n,}：代表数量，表示重复n次或者更多次 {n,m}:代表数量，表示重复n到m次 []:指定范围，匹配中括号范围内的字符，如[0-9a-zA-Z]匹配0～9，a～z，A～Z的字符 [^x] :匹配除了x以外的任意字符 |:表示分支条件，可以理解为或 &nbsp;&nbsp;&nbsp;&nbsp;当然如果要匹配元字符本身的话，需要使用 \\ 来取消元字符本身的特殊含义,例如，使用.可以匹配到 . ,使用\\ 可以匹配到 \\ 利用上述讲的一些规则拼拼凑凑就可以实现一些常用字符串的验证啦，比如下面的一些： 验证帐号，数字,字母，下划线组成，以字母开头，长度5到9位：^[a-zA-Z]\\w{5,9}$ 验证手机号，以1开头，长度11位（乞丐版验证）：^1\\d{10}$ 一个匹配ip地址的正则表达式:^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?$) 一个匹配邮箱的正则表达式：^[0-9a-zA-Z](\\w|.|-)*@[0-9a-zA-Z]+.(com|cn|net|me|pro｜edu|gov)$ 暂时先写这么多吧。话说来滴滴实习之后一直忙于业务上的事，这个博客已经停更很久了。以后还是会坚持写。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"块级格式化上下文(BFC)","date":"2017-03-07T08:02:34.000Z","path":"2017/03/07/块级格式化上下文(BFC)/","text":"由于平时主要在写JavaScript，在最近找实习的过程中有意识的复习了一下css基础，发现自己在以往的学习和应用中太过于忽视css基础了，对于好多小技巧都处在知其然而不知所以然的阶段，比如知道给父级元素设置overflow:hidden或者overflow:auto;可以清除子元素的浮动(其实这种说法也不够准确，应该说可以包含浮动),但是却不知道为什么可以实现这个效果。在探究这个问题的过程中学习到了CSS2.1当中一个很重要但自己却鲜有了解的概念，Block formatting contexts(块级格式化上下文)，以下简要记录一下对这个概念的学习与了解。 W3C标准中这样介绍BFC： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 由此我们了解了触发BFC可以有以下几种方式: float设置left或right overflow设置为visible以外的值(auto,hidden,scroll) display属性设置为inline-block，table-cells或者table-captions position设置为绝对定位(absolute，fixed) 知道了触发BFC的几种方式，那么它的应用场景有哪些呢？ 1.使用BFC包含浮动 创建了BFC的元素相当于创建了一个独立的盒子，里面的元素在布局上不会影响外面的元素，反之亦然，同时BFC仍然属于文档中的普通流。因此我们刚刚提到的设置父元素overflow ＝ hidden ｜｜ auto的方式实际上是创建了一个BFC，而按照BFC的本意来说，必须给里面浮动的元素撑起来高度才能达到“在布局上不影响外面元素”的效果，否则由于高度“坍塌“会使后面的元素较原位置向上，因此创建BFC可以有清除浮动的效果，但是此处叫做包含浮动比较好。例子如下： 1234567891011 &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt; inner1 &lt;/div&gt; &lt;div class=\"inner\"&gt; inner2 &lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt; footer&lt;/div&gt; 12345678910111213141516 .outer&#123; border: 1px solid red; overflow: auto;/*设置为hidden也可以实现效果*/ &#125;.inner&#123; width: 300px; height: 100px; border: 1px solid green; float: left;&#125;.footer&#123; height: 100px; border: 1px solid black;&#125; 效果如图： 这样就达到了预期的效果。当然最常用的清除浮动的方法依然是添加伪元素并设置其clear，这里就不展开介绍了。 2.使用BFC阻止外边距叠加 当两个相邻的元素在同一个BFC中时，它们之间在垂直方向的外边距会叠加（水平方向上不会），也就是说会取max｛first.margin-bottom,second.margin-top｝来作为first与second元素之间的间距。那么，如果两个元素不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。因此可以使用构造BFC的方法来阻止元素外边距的叠加。例子如下：12345678&lt;div class=\"div1\"&gt; div1&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;!--创建外层div，构造BFC--&gt; &lt;div class=\"div2\"&gt; div2 &lt;/div&gt;&lt;/div&gt; 12345678910111213.div1&#123; height: 100px; border: 1px solid red; margin-bottom: 50px;&#125;.div2&#123; height: 100px; border: 1px solid green; margin-top: 50px;&#125;.container&#123; overflow: auto; &#125; 效果如图：在div2的外层添加了一层div，并且设置其overflow属性为auto，这就创建了一个BFC，div1与div2处于两个BFC中，因此不会产生外边距叠加。可以看到，div1与div2之间的外边距已经是100px。 3.使用BFC避免文字环绕首先明确一下要解决的问题，在很多场景下都会用到一种 左侧图片＋右边信息的两栏结构，如果不做处理就会产生文字环绕的问题，如图： 为什么会产生这种问题呢？在《精通CSS：高级Web标准解决方案（第2版）》中有这样一段话很好的解释了原因： 浮动会让元素脱离文档流，不再影响不浮动的元素。实际上，并不完全如此。如果浮动的元素后边得有一个文档流中的元素，那么这个元素的框就会表现得像浮动根本不存在一样。但是，框的文本内容会受到浮动元素的影响，会移动以留出空间。用技术术语来说，浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。 也就是说虽然p元素位置没有受到影响，但是其内部文本内容会为浮动的元素流出位置，因此在上半部分会向右移动，当浮动元素结束时又恢复了正常。可以使用BFC来解决这个问题，首先还是回顾一下W3C规范： 在BFC上下文中，每个盒子的左外侧紧贴包含块的左侧（从右到左的格式里，则为盒子右外侧紧贴包含块右侧），甚至有浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。 因此我们可以为右侧的P元素创建一个新的BFC那么它就不会在紧贴着包含块的左侧了，这样其内部的文本自然也就不会产生环绕。例子如下： 1234&lt;div class=\"outer\"&gt; &lt;div&gt;左浮动&lt;/div&gt; &lt;p&gt;这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容&lt;/p&gt;&lt;/div&gt; 123456789101112131415.outer&#123; width: 200px; height: 200px; border:1px solid red;&#125;.outer div&#123; float: left; width: 100px; height: 100px; background: gray;&#125;.outer p&#123; margin: 0; overflow: auto;&#125; 效果如图： 以上便是对于块级格式化上下文应用场景的一些简要介绍，了解并合理的利用BFC对于每位CSSer还是十分必要的。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"webpack打包性能优化","date":"2017-02-27T04:50:16.000Z","path":"2017/02/27/webpack打包性能优化/","text":"最近尝试使用webpack来做前端资源模块化管理以及打包，感觉开发体验提升了不少，webpack将任何资源都视作模块，默认情况下统统打包进一个文件（bundle.js），这种all in JS 的方式我非常喜欢。但是同时也带来了一些问题，随着静态资源以及模块的增多，bundle.js会变的臃肿不堪，这就导致编译时间会大幅度上升，在使用热更新的情况下，甚至我们改动了一行代码都要重新编译一遍，等待时间可达到几十秒，这对我们的开发体验是非常不利的。同时，对于单页应用来说，所有的资源都在首屏时加载，会拖慢我们应用的首屏时间，导致用户体验变差。显然这种方式是十分粗暴的，因此需要进行合理的优化，以下是我近两天采用的一些方法。 1.抽离公共代码块 对于常用的类库或者common代码块来说，基本上我们不会修改到，因此我们可以把这一部分代码抽离出来，单独打包成一个文件，在入口的html文件当中单独引入。webpack中提供了内置的插件帮我们实现这个功能，例如我们想要将jquery单独打包，可以采用下面这种做法：1234567entry:&#123; path:__dirname+\"/src/entry.js\", vendor:[\"jquery\"] &#125; plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123;name:\"vendor\",filename:\"vendor.js\"&#125;) ] 以上就将jquery单独打包为vendor.js，随后在入口的html文件中引入即可，如下：12&lt; script type=\"text/javascript\" src=\"vendor.js?24f0580a0c65db9f9ddd\"&gt;&lt;/script&gt;&lt; script type=\"text/javascript\" src=\"bundle.js?24f0580a0c65db9f9ddd\"&gt;&lt;/script&gt; 通过以上方式可以有效的提升开发时的体验，抽离出的公共部分不参与打包（热更新的情况下），减少了开发时编译的等待时间。 2.按需加载 对于单页应用，在首屏时加载所有的静态资源是非常低效的，因为并不是所有的模块都会立刻使用到，对于这一类的模块，我们可以在需要的时候加载。如果使用commonjs规范的话，可以使用如下的做法：1234 require.ensure([\"hellojs\"],function()&#123; var hello = require(\"hellojs\"); // and so on &#125;) 这样做在编译过程中会多生成一个文件 x.bundle.js，这个文件就是hello.js对应生成的包，只有当我们需要使用到它时，才会加载，这样就减少了bundle.js的大小，也就是说优化了首屏显示的速度。 3.代码压缩这是一种非常常见的做法，因此不做赘述。在webpack中有内置插件可以使用，推荐在上线时才开启。12345678new webpack.optimize.UglifyJsPlugin(&#123; //代码压缩 compress:&#123; warnings:false, &#125;, output:&#123; comments:false, &#125;, &#125;) 以上便是最近两天所使用的一些方法，当然还有很多可以优化的地方，我也在不断的学习，使用。 参考：https://webpack.github.io/docs/code-splitting.html#commons-chunk","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"个人网站开通啦","date":"2017-02-26T11:38:59.000Z","path":"2017/02/26/个人网站开通啦/","text":"这是一个使用GithubPages+Hexo搭建的个人博客,主题是使用的yilia,在这里先感谢作者的无私分享。今后会在这个网站上更新一下自己学习的经验以及生活上的一些感悟。","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]