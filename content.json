[{"title":"正则入门","date":"2017-05-12T08:32:21.000Z","path":"2017/05/12/正则入门/","text":"&nbsp;&nbsp;&nbsp;&nbsp;正则表达式在前端开发当中还是很常用的，它可以帮助我们完成一些复杂字符串的匹配，搜索和替换工作，比如说 验证邮箱格式，验证手机号码以及其他一些更高级的应用。当然作为一个前端渣，只是用正则来解决一些业务上的问题，并没有过更高级的应用 －－！写这篇文章的主要目的也只是记录一下正则的常用语法，这样以后有遗忘的时候就不用到处找地方查了 －－！ 以下是一些常用的元字符和搭配： ^: 匹配字符串的开始 $: 匹配字符串的结束 .: 匹配除了换行符之外的任何字符 \\w: 匹配字母或者数组或者下划线或者汉字。\\W(w字母大写)表示其反义，即匹配任意不是字母，数字，下划线，汉字的字符 \\b: 匹配单词的开头和结尾，即单词的分界处。\\B表示其反义 \\d: 匹配一个数字,\\d{2}匹配两个数字，\\d{2,5}匹配2个到5个数字。\\D表示其反义 \\s: 匹配任意的空白符，包括空格，制表符，换行符等。\\S表示其反义 *: 代表数量，指定＊前面的内容可以连续重复的使用任意次数(零次或者更多次)来使表达式匹配，和.连用即 .＊的时候,表示任意数量的不包含换行的字符 +:代表数量，表示重复一次或者更多次 ？：代表数量，表示重复零次或者一次 {n}:代表数量，表示重复n次 {n,}：代表数量，表示重复n次或者更多次 {n,m}:代表数量，表示重复n到m次 []:指定范围，匹配中括号范围内的字符，如[0-9a-zA-Z]匹配0～9，a～z，A～Z的字符 [^x] :匹配除了x以外的任意字符 |:表示分支条件，可以理解为或 &nbsp;&nbsp;&nbsp;&nbsp;当然如果要匹配元字符本身的话，需要使用 \\ 来取消元字符本身的特殊含义,例如，使用.可以匹配到 . ,使用\\ 可以匹配到 \\ 利用上述讲的一些规则拼拼凑凑就可以实现一些常用字符串的验证啦，比如下面的一些： 验证帐号，数字,字母，下划线组成，以字母开头，长度5到9位：^[a-zA-Z]\\w{5,9}$ 验证手机号，以1开头，长度11位（乞丐版验证）：^1\\d{10}$ 一个匹配ip地址的正则表达式:^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?$) 一个匹配邮箱的正则表达式：^[0-9a-zA-Z](\\w|.|-)*@[0-9a-zA-Z]+.(com|cn|net|me|pro｜edu|gov)$ 暂时先写这么多吧。话说来滴滴实习之后一直忙于业务上的事，这个博客已经停更很久了。以后还是会坚持写。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"块级格式化上下文(BFC)","date":"2017-03-07T08:02:34.000Z","path":"2017/03/07/块级格式化上下文(BFC)/","text":"由于平时主要在写JavaScript，在最近找实习的过程中有意识的复习了一下css基础，发现自己在以往的学习和应用中太过于忽视css基础了，对于好多小技巧都处在知其然而不知所以然的阶段，比如知道给父级元素设置overflow:hidden或者overflow:auto;可以清除子元素的浮动(其实这种说法也不够准确，应该说可以包含浮动),但是却不知道为什么可以实现这个效果。在探究这个问题的过程中学习到了CSS2.1当中一个很重要但自己却鲜有了解的概念，Block formatting contexts(块级格式化上下文)，以下简要记录一下对这个概念的学习与了解。 W3C标准中这样介绍BFC： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 由此我们了解了触发BFC可以有以下几种方式: float设置left或right overflow设置为visible以外的值(auto,hidden,scroll) display属性设置为inline-block，table-cells或者table-captions position设置为绝对定位(absolute，fixed) 知道了触发BFC的几种方式，那么它的应用场景有哪些呢？ 1.使用BFC包含浮动 创建了BFC的元素相当于创建了一个独立的盒子，里面的元素在布局上不会影响外面的元素，反之亦然，同时BFC仍然属于文档中的普通流。因此我们刚刚提到的设置父元素overflow ＝ hidden ｜｜ auto的方式实际上是创建了一个BFC，而按照BFC的本意来说，必须给里面浮动的元素撑起来高度才能达到“在布局上不影响外面元素”的效果，否则由于高度“坍塌“会使后面的元素较原位置向上，因此创建BFC可以有清除浮动的效果，但是此处叫做包含浮动比较好。例子如下： 1234567891011 &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt; inner1 &lt;/div&gt; &lt;div class=\"inner\"&gt; inner2 &lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt; footer&lt;/div&gt; 12345678910111213141516 .outer&#123; border: 1px solid red; overflow: auto;/*设置为hidden也可以实现效果*/ &#125;.inner&#123; width: 300px; height: 100px; border: 1px solid green; float: left;&#125;.footer&#123; height: 100px; border: 1px solid black;&#125; 效果如图： 这样就达到了预期的效果。当然最常用的清除浮动的方法依然是添加伪元素并设置其clear，这里就不展开介绍了。 2.使用BFC阻止外边距叠加 当两个相邻的元素在同一个BFC中时，它们之间在垂直方向的外边距会叠加（水平方向上不会），也就是说会取max｛first.margin-bottom,second.margin-top｝来作为first与second元素之间的间距。那么，如果两个元素不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。因此可以使用构造BFC的方法来阻止元素外边距的叠加。例子如下：12345678&lt;div class=\"div1\"&gt; div1&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;!--创建外层div，构造BFC--&gt; &lt;div class=\"div2\"&gt; div2 &lt;/div&gt;&lt;/div&gt; 12345678910111213.div1&#123; height: 100px; border: 1px solid red; margin-bottom: 50px;&#125;.div2&#123; height: 100px; border: 1px solid green; margin-top: 50px;&#125;.container&#123; overflow: auto; &#125; 效果如图：在div2的外层添加了一层div，并且设置其overflow属性为auto，这就创建了一个BFC，div1与div2处于两个BFC中，因此不会产生外边距叠加。可以看到，div1与div2之间的外边距已经是100px。 3.使用BFC避免文字环绕首先明确一下要解决的问题，在很多场景下都会用到一种 左侧图片＋右边信息的两栏结构，如果不做处理就会产生文字环绕的问题，如图： 为什么会产生这种问题呢？在《精通CSS：高级Web标准解决方案（第2版）》中有这样一段话很好的解释了原因： 浮动会让元素脱离文档流，不再影响不浮动的元素。实际上，并不完全如此。如果浮动的元素后边得有一个文档流中的元素，那么这个元素的框就会表现得像浮动根本不存在一样。但是，框的文本内容会受到浮动元素的影响，会移动以留出空间。用技术术语来说，浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。 也就是说虽然p元素位置没有受到影响，但是其内部文本内容会为浮动的元素流出位置，因此在上半部分会向右移动，当浮动元素结束时又恢复了正常。可以使用BFC来解决这个问题，首先还是回顾一下W3C规范： 在BFC上下文中，每个盒子的左外侧紧贴包含块的左侧（从右到左的格式里，则为盒子右外侧紧贴包含块右侧），甚至有浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。 因此我们可以为右侧的P元素创建一个新的BFC那么它就不会在紧贴着包含块的左侧了，这样其内部的文本自然也就不会产生环绕。例子如下： 1234&lt;div class=\"outer\"&gt; &lt;div&gt;左浮动&lt;/div&gt; &lt;p&gt;这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容&lt;/p&gt;&lt;/div&gt; 123456789101112131415.outer&#123; width: 200px; height: 200px; border:1px solid red;&#125;.outer div&#123; float: left; width: 100px; height: 100px; background: gray;&#125;.outer p&#123; margin: 0; overflow: auto;&#125; 效果如图： 以上便是对于块级格式化上下文应用场景的一些简要介绍，了解并合理的利用BFC对于每位CSSer还是十分必要的。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"webpack打包性能优化","date":"2017-02-27T04:50:16.000Z","path":"2017/02/27/webpack打包性能优化/","text":"最近尝试使用webpack来做前端资源模块化管理以及打包，感觉开发体验提升了不少，webpack将任何资源都视作模块，默认情况下统统打包进一个文件（bundle.js），这种all in JS 的方式我非常喜欢。但是同时也带来了一些问题，随着静态资源以及模块的增多，bundle.js会变的臃肿不堪，这就导致编译时间会大幅度上升，在使用热更新的情况下，甚至我们改动了一行代码都要重新编译一遍，等待时间可达到几十秒，这对我们的开发体验是非常不利的。同时，对于单页应用来说，所有的资源都在首屏时加载，会拖慢我们应用的首屏时间，导致用户体验变差。显然这种方式是十分粗暴的，因此需要进行合理的优化，以下是我近两天采用的一些方法。 1.抽离公共代码块 对于常用的类库或者common代码块来说，基本上我们不会修改到，因此我们可以把这一部分代码抽离出来，单独打包成一个文件，在入口的html文件当中单独引入。webpack中提供了内置的插件帮我们实现这个功能，例如我们想要将jquery单独打包，可以采用下面这种做法：1234567entry:&#123; path:__dirname+\"/src/entry.js\", vendor:[\"jquery\"] &#125; plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123;name:\"vendor\",filename:\"vendor.js\"&#125;) ] 以上就将jquery单独打包为vendor.js，随后在入口的html文件中引入即可，如下：12&lt; script type=\"text/javascript\" src=\"vendor.js?24f0580a0c65db9f9ddd\"&gt;&lt;/script&gt;&lt; script type=\"text/javascript\" src=\"bundle.js?24f0580a0c65db9f9ddd\"&gt;&lt;/script&gt; 通过以上方式可以有效的提升开发时的体验，抽离出的公共部分不参与打包（热更新的情况下），减少了开发时编译的等待时间。 2.按需加载 对于单页应用，在首屏时加载所有的静态资源是非常低效的，因为并不是所有的模块都会立刻使用到，对于这一类的模块，我们可以在需要的时候加载。如果使用commonjs规范的话，可以使用如下的做法：1234 require.ensure([\"hellojs\"],function()&#123; var hello = require(\"hellojs\"); // and so on &#125;) 这样做在编译过程中会多生成一个文件 x.bundle.js，这个文件就是hello.js对应生成的包，只有当我们需要使用到它时，才会加载，这样就减少了bundle.js的大小，也就是说优化了首屏显示的速度。 3.代码压缩这是一种非常常见的做法，因此不做赘述。在webpack中有内置插件可以使用，推荐在上线时才开启。12345678new webpack.optimize.UglifyJsPlugin(&#123; //代码压缩 compress:&#123; warnings:false, &#125;, output:&#123; comments:false, &#125;, &#125;) 以上便是最近两天所使用的一些方法，当然还有很多可以优化的地方，我也在不断的学习，使用。 参考：https://webpack.github.io/docs/code-splitting.html#commons-chunk","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"个人网站开通啦","date":"2017-02-26T11:38:59.000Z","path":"2017/02/26/个人网站开通啦/","text":"这是一个使用GithubPages+Hexo搭建的个人博客,主题是使用的yilia,在这里先感谢作者的无私分享。今后会在这个网站上更新一下自己学习的经验以及生活上的一些感悟。","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]