[{"title":"react 高阶组件","date":"2017-07-24T12:47:56.000Z","path":"2017/07/24/react-高阶组件/","text":"高阶组件(higher-order component，HOC)是React中复用组件逻辑的一种进阶技巧，是对React代码进行更高层次重构的好方法。它本身并不是React自带的api，可以说是一种React当中的组件设计理念。具体来说，高阶组件就是一个React包裹着另外一个React组件，从实现上来说，它一般指的是以一个组件为参数，并且返回新组件的方法。我们首先给出一个最简单的高阶组件的实现：1234567const HighOrderComponent = (WrappedComponent) =&gt; &#123; return class HOC extends React.Component&#123; render()&#123; return &lt;WrappedComponent &#123;...this.props&#125;/&gt; &#125; &#125;&#125; 不难发现，上述方法中我们传入了一个WrappedComponent（即被包裹的组件），然后在方法中新的组件，在这个组件的render 方法中我们返回了一个被包裹组件的React Element。这个实现其实很容易理解，跟我们平时自定义react组件的方法比较类似。我们可以这样来使用这个高阶组件：12const EnhancedCopmonent = HighOrderComponent(WrappedComponent);export default EnhancedComponent; 这样我们就构造出了一个新的组件EnhanceComponent，它可以像普通的组件一样来进行使用。那么问题来了，高阶组件到底有什么用处呢？一般来讲 高阶组件有一下几个作用：1.操作props2.处理跨组件的需求3.用其他的元素包裹 WrappedComponent组件下面我们一个一个来讲： 操作props可以读取或者改变 传给WrappedComponent的props。比如说增加新的props，举例来说：12345678910const HighOrderComponent = (WrappedComponent) =&gt; &#123; return class HOC extends React.Component&#123; render()&#123; const newProps = &#123; test:'this is a new props' &#125; return &lt;WrappedComponent &#123;...this.props&#125; &#123;...newProps&#125;/&gt; &#125; &#125;&#125; 这样我们就增加了传给WrappedComponent的props。 处理跨组件的需求我认为这个是最常用到的一个作用，我们可以提取出相似模块的公用的代码。下面举例来说明：假如说我们目前有两个模块，在渲染之后分别去请求相同的接口数据，在使用的时候有一些差异，如下：12345678910111213141516171819202122232425//component Test1import React from 'react';import * as API from './api';export default class Test1 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; data:&#123;&#125; &#125; &#125; componentDidMount()&#123; API.getData().then(data =&gt; &#123; this.setState(&#123;data&#125;) &#125;) &#125; render()&#123; const &#123;data&#125; = this.state return ( &lt;div&gt; &#123;data.test1&#125; &lt;/div&gt; ) &#125;&#125; 12345678910111213141516171819202122232425// component Test2import React from 'react';import * as API from './api';export default class Test2 extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; data:&#123;&#125; &#125; &#125; componentDidMount()&#123; API.getData().then(data =&gt; &#123; this.setState(&#123;data&#125;) &#125;) &#125; render()&#123; const &#123;data&#125; = this.state return ( &lt;div&gt; &#123;data.test2&#125; &lt;/div&gt; ) &#125;&#125; 在上述的例子中，组件Test1和组件Test2在相同的接口请求了数据，只是在使用的时候有不同，Test1渲染了data.test1,Test2渲染了data.test2。可以想象，这种场景还是比较容易出现的，如果每次出现我们都重新写一遍相同的constructor和componentDidMount，这显然是有点不科学的。因此我们可以通过使用高阶组件来优化这种情况。如以下例子； 1234567891011121314151617181920212223import React from 'react';import * as API from './api';export default getData = (WrappedComponent)=&gt;&#123; return class DataLoader extends React.Component&#123; constructor(props)&#123; super(props); this.state = &#123; data:&#123;&#125; &#125; &#125; componentDidMount()&#123; API.getData().then(data =&gt; &#123; this.setState(&#123;data&#125;) &#125;) &#125; render()&#123; const &#123;data&#125; = this.state; return ( &lt;WrappedComponent data=&#123;data&#125;/&gt; ) &#125; &#125;&#125; 我们在DataLoader高阶组件中去获取了数据，并将数据作为props传递给被包裹的组件，这样就实现了提取公用的代码。这样的话，以前的Test1和Test2就可以写成无状态组件。改写如下：123456 import getData from './DataLoader'; let Test1 = (&#123;data&#125;) =&gt; ( &lt;div&gt;&#123;data1.test1&#125;&lt;/div&gt;)export default getData(Test1);//Test2同理 用其他元素包裹WrappedComponent组件","tags":[{"name":"react","slug":"react","permalink":"http://yoursite.com/tags/react/"}]},{"title":"JavaScript设计模式小记之发布/订阅者模式","date":"2017-07-16T11:49:34.000Z","path":"2017/07/16/JavaScript设计模式小记之发布－－订阅者模式/","text":"发布/订阅者模式是JavaScript开发当中常用的设计模式，大量的库或者框架的开发中都应用到了这种设计模式。今天我们就理解一下这种设计模式的应用场景及优势，并实现一个简易的发布/订阅者模式。 顾名思义，发布订阅者模式当中存在两种角色，即发布者和订阅者。订阅者是指的是当请求在某些事件(event)到达时通知它并执行相应的动作(action)，而发布者则是相对于订阅者来的，它会告知订阅者事件(event)已经到达，可以执行相应的动作。通过刚才的表述，不难发现，订阅者订阅事件实际上是在发布者对象的数组中写入要订阅的事件，即注册事件；而发布者发布的时候实际上是在依次执行订阅者订阅的对应类型的方法。 说到这里熟悉angular的人可能能够想到，其$broadcast／$on服务本质上就是一个发布订阅者模式。当内部数据或者对象发上变化或者完成某个操作时(如异步请求数据获得结果后)，我们通过$broadcast一个消息来发送给对应的接受者，而接收者通过$on收到对应消息之后就会执行里面的对应逻辑,这样就轻松的实现了代码之间的解耦，不同的模块之间只是相互通知而已，就不需要继续写在一起了,这也是发布订阅者模式最大的作用了。 说了那么多，下面我们自己实现一个简易的发布／订阅者模式。通过刚才的分析，首先应该有一个容器来保存不同消息类型下面注册的各种方法，，还需要有发布者发布消息的方法，订阅者注册对应消息类型下面方法的方法，此外，当订阅者不需要继续订阅某个消息类型下方法时，应该提供一个取消订阅的方法。具体的实现代码如下：1234567891011121314151617181920212223242526272829303132333435363738var PubSub = (function () &#123; //存放所有类型下方法的对象 var _message = &#123;&#125;; return &#123; //发布 publish: function (type, args) &#123; if (!_message[type]) &#123; return; &#125;; var e = &#123; type:type, args:args &#125; for (var i = 0; i &lt; _message[type].length; i++) &#123; _message[type][i](e); &#125; &#125;, //订阅(即注册方法) subscribe: function (type, fn) &#123; if (!_message[type]) &#123; _message[type] = [fn]; &#125; else &#123; _message[type].push(fn); &#125; &#125;, //取消订阅 unsubscribe: function (type, fn) &#123; if (!_message[type]) &#123; return; &#125; for (var i = 0; i &lt; _message[type].length; i++) &#123; if (_message[type][i] === fn) &#123; _message[type].splice(i, 1); &#125; &#125; &#125; &#125; &#125;)(); 12345678//对上述代码进行测试PubSub.subscribe('test',function(e)&#123; console.log(e.type,e.args); &#125;); PubSub.publish('test',&#123; arg1:'1', arg2:2 &#125;) 在测试代码当中我们订阅了test事件，当test被push时，执行后面的方法。随后在下面我们publish被订阅的test事件，并传入方法之行的参数。测试结果发现订阅的方法能够正确执行。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"JavaScript设计模式小记－－工厂模式","date":"2017-07-10T07:58:50.000Z","path":"2017/07/10/JavaScript设计模式小记之工厂模式/","text":"工厂模式可以说是最常用的实例化对象的模式了，它的实质是用工厂方法来代替new操作的一种模式。下面分别对简单工厂模式，工厂方法模式与抽象工厂模式在JavaScript中的应用做一下介绍。 简单工厂模式简单工厂模式（Simple Factory)：又叫做静态工厂方法，它有一个工厂方法来决定创建哪一种对象类的实例，主要用来创建同一种类型的实例。具体来说，当我们使用简单工厂模式时，不需要具体关注创建的实例到底依赖于哪个类，只需要知道有这个类就可以了。下面来列举一个简单工厂模式的例子： 12345678910111213141516171819202122232425262728 function Cat()&#123; this.sort = 'cat'; &#125;; Cat.prototype.getSort = function()&#123; console.log(this.sort); console.log('this is a cat'); &#125;; function Dog()&#123; this.sort = 'dog'; &#125;; Dog.prototype.getSort = function()&#123; console.log(this.sort); console.log('this.is a dog'); &#125;; // and so on//下面写一个工厂方法来包装上述动物类function AnimalFactory(animal)&#123; switch(animal)&#123; case 'cat': return new Cat(); case 'dog': return new Dog(); //and so on &#125;;&#125;;//创建一个实例var cat1 = AnimalFactory('cat');cat1.getSort(); 从上面的例子中不难想象，在已有工厂的基础上扩展出新的类，我们不仅需要写出这个新的类，如：function Bird(){…}，还需要在工厂方法中去增加这个新的类型，这样显然是有点低效的，因此需要创建多类对象时，简单工厂模式是有一些不太适用的。 工厂方法模式 工厂方法模式(Factory Method):通过对产品类的抽象使其创建业务主要负责用于创建多类产品的实例。工厂方法模式的本意是说将实际创建对象工作推迟到子类当中去。这样核心类就成了抽象类，不过在JavaScript中没有像传统抽象类那样的方式轻松创建抽象类，因此在JavaScript当中实现工厂方法模式我们只需要关注其核心思想，因此我们可以将工厂方法看作是一个实例化对象的工厂类。还是使用上述例子： 1234567891011121314function AnimalFactory(animal)&#123; if(!(this instanceof AnimalFactory))&#123; return new AnimalFactory(animal); &#125;; this.animal = animal;&#125;;AnimalFactory.prototype = &#123; cat:function()&#123; // .... &#125;, dog:function()&#123; //.... &#125;&#125;; 使用工厂方法模式可以非常方便的创建多个种类的实例对象，在js的实现当中，可以将这些不同的种类定义在工厂类的原型链上，这样只需要区分具体的类型即可，也不需要关注创建该种类对象的具体类。 抽象工厂模式 在介绍抽象工厂模式之前，首先介绍一下抽象类，抽象类是一种声明但是不能使用的类使用时就会报错，在JS中，可以如下模拟抽象类： 123456function Cat()&#123;&#125;Cat.prototype = &#123; getType:function()&#123; throw new Error('抽象方法无法调用')； &#125;;&#125;; 上面的例子中，我们创建的Cat类其实不能做任何事，首先其创建时没有任何属性，调用原型的方法时也会抛出错误。但是这个类在继承的时候却是有用的，因为定义了一个类，并且定义了这个类上必须的方法，当有类继承于这个类时，如果子类中没有实现对应的方法，那么当调用时就会沿着原型链找到这些方法，从而报错。 说回到抽象工厂模式，它其实并不用于创建具体的对象，而是一般用它作为父类来创建一些子类。同样举例来说明： 123456789101112131415161718192021222324252627282930313233343536373839404142434445//抽象工厂方法function VehicleFactory(subType,superType)&#123; if(typeof VehicleFactory[superType] === 'function')&#123; function F()&#123;&#125;; F.prototype = new VehicleFactory[superType](); subType.prototype.constructor = subType; subType.prototype = new F(); &#125;else&#123; throw new Error('未创建改抽象类') &#125;;&#125;;//具体的抽象类,将类直接创建为工厂方法的属性即可VehicleFactory.Dog = function()&#123; this.type = 'dog';&#125;;VehicleFactory.Dog.prototype =&#123; getType:function()&#123; throw new Error('抽象类无法调用'); &#125;;&#125;;VehicleFactory.Cat = function()&#123; this.type = 'cat'&#125;;VeicleFactory.Cat.prototype = &#123; getType:function()&#123; throw new Error('抽象类无法使用') &#125;;&#125;;//具体使用，创建子类继承//萨摩耶类function Samoyed(name)&#123; this.name = 'Samoyed';&#125;VehicleFactory(Samoyed,'Dog');console.log(samoyed1.name);console.log(samoyed1.type)samoyed1.getType()//此时会报错，因为子类上没有实现getType方法//重写getType方法Samoyed.prototype.getType = function()&#123; console.log(this.type)&#125;var samoyed1 = new Samoyed('samoyed1');console.log(samoyed1.name);console.log(samoyed1.type)samoyed1.getType()//此时可以正确输出 在上述代码中，抽象工厂方法实际上是一个实现子类继承父类的方法，通过向这个方法中传递子类与父类名称，其内部实现子类继承父类。由于JavaScript当中不支持抽象化创建与虚拟方法，所以导致这种模式在JS当中应用并不是特别广泛。","tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"前后端接口规范简要记录","date":"2017-06-10T14:25:14.000Z","path":"2017/06/10/前后端接口规范简要记录/","text":"前后端分离的开发模式当中，关于接口方面的开发调试会占据相当大的比例，因此接口规则的约定以及接口文档的规范性还是十分重要的，以前的在实验室的项目中在这方面做得就不太好。最近实验室要开一个新的项目，在项目开始前也思考了一下这个问题并就自己目前的了解定义了一些简单的规则，在这边也做一下纪录。 接口说明 1.前后端接口命名方式为驼峰式，例如userName，getFormData等等。 2.默认情况下前端请求数据的content－type设置为Content-Type：application/x-www-form-urlencoded，方便后端直接拿到请求值 3.后端返回数据必须包含status项，以方便前端判断。具体采用如下格式：12345678910&#123; data:&#123; //项目中实际的返回数据用data包裹 &#125; status:｛ code:0, msg:'登陆成功' &#125;&#125; 其中，data与status同级别，项目中实际返回的数据用data包裹，如果不需要返回数据则只返回status，说明此次请求的结果是怎么样的。status由code和msg组成，code为自定义的返回码，一般默认0为相关请求成功，其余的码由前后端根据业务商定；msg为对于状态码的相关说明，如操作失败，操作成功，查询成功等等等。 4.对于每一个请求，前端在拿到请求数据之后首先判断status再做后续业务相关的操作。 5.每一个借口均需要生成借口文档 下面我们举一个接口文档的例子 登陆模块请求 请求说明：用户登录 method:‘POST’ Content-Type：application/x-www-form-urlencoded url:/user/login 参数 说明 是否必须 默认值 类型 userName 用户名 是 无 string password 密码 是 无 string 请求示例1234&#123; userName:&apos;gonglei&apos;, password:&apos;123456&apos;&#125; 响应示例12345678&#123;//因为不需要data项故只返回status即可。 status:｛ code:0, msg:&apos;登陆成功&apos; &#125;&#125;","tags":[{"name":"编程规范","slug":"编程规范","permalink":"http://yoursite.com/tags/编程规范/"}]},{"title":"Web IDE之Terminal组件开发","date":"2017-05-22T07:41:42.000Z","path":"2017/05/22/Web-IDE之Terminal组件开发/","text":"&nbsp;&nbsp;&nbsp;&nbsp;随着web技术的发展，越来越多的客户端的程序正逐渐搬到了浏览器上面。比如web端的IDE，web端的一些团队管理工具如teambition等。然后挺久之前在知乎上看到过coding的架构师写的一篇关于Web IDE实现的答案，很感兴趣，一直想有所尝试。正巧组上最近在开发一款公司内部使用的WebIDE项目，主要负责其中的terminal组件开发。我和大多数的开发者是一样的，每天都在高频率的使用terminal，但是对于其实现的原理却不了解。经过上周的一些搜索和实践，最终搞清了它的原理，并写了一个demo出来。现在记录一下上周的一些学习和实践的历程。 1.Terminal原理 &nbsp;&nbsp;&nbsp;&nbsp;首先应该了解的是Terminal，bash和shell之间的区别。我们通常所说的Terminal是指的终端模拟器，比如mac上自带的terminal.app和更常用的item2等，它们都是直面用户的gui程序。然后shell是命令行解释器，它的职责是执行终端设备传递过来的字符串和控制字符，执行相应的命令，通俗点讲，就是接受用户命令，调用相关应用程序。而bash是shell中的一种，其它还有功能更强大的如zsh等等。 &nbsp;&nbsp;&nbsp;&nbsp;一般情况下终端模拟器是不会直接与shell通讯的，而是通过pty（Pseudoterminal，伪终端）来实现。pty 是一对 master-slave 设备，master 设备表现得像一个文件，slave 设备表现得像一个终端设备。终端模拟器通过文件读写流与 pyt master通讯，pty master再将字符输入经过线路规程的转换传送给nty slave，slave进一步传递给bash。整个过程大概如下：1终端模拟器(item2,terminal.app等) ——&gt; nty master ——&gt; nty slave ——&gt; shell(bash,zsh等) 这样shell就能接收到用户的输入并执行相应的命令了。 2.Web Terminal的实现原理&nbsp;&nbsp;&nbsp;&nbsp;理解了terminal的原理之后，对于在web端的实现仍然没有什么头绪，直到看到coding 总结的一副原理图才有了一些想法，在这里引用一下：通过上面的图可以看出，整个terminal组件从前端到后台的实现当中，大概要做一下几个东西： 在浏览器端实现的终端模拟器(前端) 前后端建立WebSocket连接，保证用户的输入能够实时推送到后端和后端的反馈相应到前端(协议) 后端创建pty对，来与终端模拟器以及shell通讯(后端) 下面会针对以上三个部分描述一下详细的实现。 3.Web Terminal的具体实现&nbsp;&nbsp;&nbsp;&nbsp;首先说一下，整个IDE项目前端使用的React全家桶，后端使用的是express，做一下说明，下面出现的代码就比较容易理解了。整体的思路就是，在组件加载后（此时并未生成terminal实例），前端首先实例化一个终端模拟器。然后请求后端生成一个pty对，后端生成 pty对后，将标识其唯一性的pty id返回给前端用以socket连接，前端拿到pty id之后与后端建立socket连接，实现实时的通讯，剩下的就是处理一些具体的操作，下面将从前端和后台两个方面进行介绍。 3.1 前端实现&nbsp;&nbsp;&nbsp;&nbsp;先说一下终端模拟器，这一方面来讲，目前有很多成熟的轮子可以直接使用，考察了一下最终选择了xterm.js这个库，原因是上手比较简单，虽然它只有demo没有文档，23333，但是看官方的demo已经足够了解了。生成终端模拟器之后与后端建立socket连接即可，贴一下部分的主要代码： 1234567891011121314151617181920212223242526import Xterm from 'xterm';import 'xterm/lib/addons/fit/fit.js';import 'xterm/lib/xterm.css';import 'xterm/lib/addons/attach/attach'; //引入相关库const &#123; pid &#125; = this.props.terminalData; //组件渲染后拿到后端声称的pty 的id，标识每一个pty对，主要为建立WebScoket连接时使用。const terminalContainer = this.terminal;const terminal = new Xterm(&#123; //生成一个Xterm类的实例 cursorBlink: true, scrollBack: 3, tabStopWidth: 3,&#125;);terminal.open(terminalContainer); //terminalContainer作为终端模拟器的容器 terminal.fit();const socketUrl = `ws://localhost:1234/terminals/$&#123;pid&#125;`;//建立socket连接的地址，注意协议为wsconst socket = new WebSocket(socketUrl); //创建WebSocketsocket.onopen = () =&gt; &#123; terminal.attach(socket); your code ...&#125;; socket.onclose = () =&gt; &#123; message.error('与服务端连接已断开'); your code ...&#125;;socket.onerror = ()=&gt;&#123; your code ...&#125; 3.2 后端实现待续…","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"Web IDE","slug":"Web-IDE","permalink":"http://yoursite.com/tags/Web-IDE/"},{"name":"Terminal","slug":"Terminal","permalink":"http://yoursite.com/tags/Terminal/"},{"name":"WebSocket","slug":"WebSocket","permalink":"http://yoursite.com/tags/WebSocket/"}]},{"title":"正则入门","date":"2017-05-12T08:32:21.000Z","path":"2017/05/12/正则入门/","text":"&nbsp;&nbsp;&nbsp;&nbsp;正则表达式在前端开发当中还是很常用的，它可以帮助我们完成一些复杂字符串的匹配，搜索和替换工作，比如说 验证邮箱格式，验证手机号码以及其他一些更高级的应用。当然作为一个前端渣，只是用正则来解决一些业务上的问题，并没有过更高级的应用 －－！写这篇文章的主要目的也只是记录一下正则的常用语法，这样以后有遗忘的时候就不用到处找地方查了 －－！ 以下是一些常用的元字符和搭配： ^: 匹配字符串的开始 $: 匹配字符串的结束 .: 匹配除了换行符之外的任何字符 \\w: 匹配字母或者数组或者下划线或者汉字。\\W(w字母大写)表示其反义，即匹配任意不是字母，数字，下划线，汉字的字符 \\b: 匹配单词的开头和结尾，即单词的分界处。\\B表示其反义 \\d: 匹配一个数字,\\d{2}匹配两个数字，\\d{2,5}匹配2个到5个数字。\\D表示其反义 \\s: 匹配任意的空白符，包括空格，制表符，换行符等。\\S表示其反义 *: 代表数量，指定＊前面的内容可以连续重复的使用任意次数(零次或者更多次)来使表达式匹配，和.连用即 .＊的时候,表示任意数量的不包含换行的字符 +:代表数量，表示重复一次或者更多次 ？：代表数量，表示重复零次或者一次 {n}:代表数量，表示重复n次 {n,}：代表数量，表示重复n次或者更多次 {n,m}:代表数量，表示重复n到m次 []:指定范围，匹配中括号范围内的字符，如[0-9a-zA-Z]匹配0～9，a～z，A～Z的字符 [^x] :匹配除了x以外的任意字符 |:表示分支条件，可以理解为或 &nbsp;&nbsp;&nbsp;&nbsp;当然如果要匹配元字符本身的话，需要使用 \\ 来取消元字符本身的特殊含义,例如，使用.可以匹配到 . ,使用\\ 可以匹配到 \\ 利用上述讲的一些规则拼拼凑凑就可以实现一些常用字符串的验证啦，比如下面的一些： 验证帐号，数字,字母，下划线组成，以字母开头，长度5到9位：^[a-zA-Z]\\w{5,9}$ 验证手机号，以1开头，长度11位（乞丐版验证）：^1\\d{10}$ 一个匹配ip地址的正则表达式:^((2[0-4]\\d|25[0-5]|[01]?\\d\\d?).){3}(2[0-4]\\d|25[0-5]|[01]?\\d\\d?$) 一个匹配邮箱的正则表达式：^[0-9a-zA-Z](\\w|.|-)*@[0-9a-zA-Z]+.(com|cn|net|me|pro｜edu|gov)$ 暂时先写这么多吧。话说来滴滴实习之后一直忙于业务上的事，这个博客已经停更很久了。以后还是会坚持写。","tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"},{"name":"正则表达式","slug":"正则表达式","permalink":"http://yoursite.com/tags/正则表达式/"}]},{"title":"块级格式化上下文(BFC)","date":"2017-03-07T08:02:34.000Z","path":"2017/03/07/块级格式化上下文(BFC)/","text":"由于平时主要在写JavaScript，在最近找实习的过程中有意识的复习了一下css基础，发现自己在以往的学习和应用中太过于忽视css基础了，对于好多小技巧都处在知其然而不知所以然的阶段，比如知道给父级元素设置overflow:hidden或者overflow:auto;可以清除子元素的浮动(其实这种说法也不够准确，应该说可以包含浮动),但是却不知道为什么可以实现这个效果。在探究这个问题的过程中学习到了CSS2.1当中一个很重要但自己却鲜有了解的概念，Block formatting contexts(块级格式化上下文)，以下简要记录一下对这个概念的学习与了解。 W3C标准中这样介绍BFC： 浮动元素和绝对定位元素，非块级盒子的块级容器（例如 inline-blocks, table-cells, 和 table-captions），以及overflow值不为“visiable”的块级盒子，都会为他们的内容创建新的BFC（块级格式上下文）。在BFC中，盒子从顶端开始垂直地一个接一个地排列，两个盒子之间的垂直的间隙是由他们的margin 值所决定的。在一个BFC中，两个相邻的块级盒子的垂直外边距会产生折叠。在BFC中，每一个盒子的左外边缘（margin-left）会触碰到容器的左边缘(border-left)（对于从右到左的格式来说，则触碰到右边缘）。 由此我们了解了触发BFC可以有以下几种方式: float设置left或right overflow设置为visible以外的值(auto,hidden,scroll) display属性设置为inline-block，table-cells或者table-captions position设置为绝对定位(absolute，fixed) 知道了触发BFC的几种方式，那么它的应用场景有哪些呢？ 1.使用BFC包含浮动 创建了BFC的元素相当于创建了一个独立的盒子，里面的元素在布局上不会影响外面的元素，反之亦然，同时BFC仍然属于文档中的普通流。因此我们刚刚提到的设置父元素overflow ＝ hidden ｜｜ auto的方式实际上是创建了一个BFC，而按照BFC的本意来说，必须给里面浮动的元素撑起来高度才能达到“在布局上不影响外面元素”的效果，否则由于高度“坍塌“会使后面的元素较原位置向上，因此创建BFC可以有清除浮动的效果，但是此处叫做包含浮动比较好。例子如下： 1234567891011 &lt;div class=\"outer\"&gt; &lt;div class=\"inner\"&gt; inner1 &lt;/div&gt; &lt;div class=\"inner\"&gt; inner2 &lt;/div&gt;&lt;/div&gt;&lt;div class=\"footer\"&gt; footer&lt;/div&gt; 12345678910111213141516 .outer&#123; border: 1px solid red; overflow: auto;/*设置为hidden也可以实现效果*/ &#125;.inner&#123; width: 300px; height: 100px; border: 1px solid green; float: left;&#125;.footer&#123; height: 100px; border: 1px solid black;&#125; 效果如图： 这样就达到了预期的效果。当然最常用的清除浮动的方法依然是添加伪元素并设置其clear，这里就不展开介绍了。 2.使用BFC阻止外边距叠加 当两个相邻的元素在同一个BFC中时，它们之间在垂直方向的外边距会叠加（水平方向上不会），也就是说会取max｛first.margin-bottom,second.margin-top｝来作为first与second元素之间的间距。那么，如果两个元素不属于同一个块级格式化上下文，那么它们的外边距就不会叠加。因此可以使用构造BFC的方法来阻止元素外边距的叠加。例子如下：12345678&lt;div class=\"div1\"&gt; div1&lt;/div&gt;&lt;div class=\"container\"&gt; &lt;!--创建外层div，构造BFC--&gt; &lt;div class=\"div2\"&gt; div2 &lt;/div&gt;&lt;/div&gt; 12345678910111213.div1&#123; height: 100px; border: 1px solid red; margin-bottom: 50px;&#125;.div2&#123; height: 100px; border: 1px solid green; margin-top: 50px;&#125;.container&#123; overflow: auto; &#125; 效果如图：在div2的外层添加了一层div，并且设置其overflow属性为auto，这就创建了一个BFC，div1与div2处于两个BFC中，因此不会产生外边距叠加。可以看到，div1与div2之间的外边距已经是100px。 3.使用BFC避免文字环绕首先明确一下要解决的问题，在很多场景下都会用到一种 左侧图片＋右边信息的两栏结构，如果不做处理就会产生文字环绕的问题，如图： 为什么会产生这种问题呢？在《精通CSS：高级Web标准解决方案（第2版）》中有这样一段话很好的解释了原因： 浮动会让元素脱离文档流，不再影响不浮动的元素。实际上，并不完全如此。如果浮动的元素后边得有一个文档流中的元素，那么这个元素的框就会表现得像浮动根本不存在一样。但是，框的文本内容会受到浮动元素的影响，会移动以留出空间。用技术术语来说，浮动元素旁边的行框被缩短，从而给浮动元素留出空间，因此行框围绕浮动框。 也就是说虽然p元素位置没有受到影响，但是其内部文本内容会为浮动的元素流出位置，因此在上半部分会向右移动，当浮动元素结束时又恢复了正常。可以使用BFC来解决这个问题，首先还是回顾一下W3C规范： 在BFC上下文中，每个盒子的左外侧紧贴包含块的左侧（从右到左的格式里，则为盒子右外侧紧贴包含块右侧），甚至有浮动也是如此（尽管盒子里的行盒子 Line Box 可能由于浮动而变窄），除非盒子创建了一个新的BFC（在这种情况下盒子本身可能由于浮动而变窄）。 因此我们可以为右侧的P元素创建一个新的BFC那么它就不会在紧贴着包含块的左侧了，这样其内部的文本自然也就不会产生环绕。例子如下： 1234&lt;div class=\"outer\"&gt; &lt;div&gt;左浮动&lt;/div&gt; &lt;p&gt;这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容这是句子的内容&lt;/p&gt;&lt;/div&gt; 123456789101112131415.outer&#123; width: 200px; height: 200px; border:1px solid red;&#125;.outer div&#123; float: left; width: 100px; height: 100px; background: gray;&#125;.outer p&#123; margin: 0; overflow: auto;&#125; 效果如图： 以上便是对于块级格式化上下文应用场景的一些简要介绍，了解并合理的利用BFC对于每位CSSer还是十分必要的。","tags":[{"name":"css","slug":"css","permalink":"http://yoursite.com/tags/css/"}]},{"title":"webpack打包性能优化","date":"2017-02-27T04:50:16.000Z","path":"2017/02/27/webpack打包性能优化/","text":"最近尝试使用webpack来做前端资源模块化管理以及打包，感觉开发体验提升了不少，webpack将任何资源都视作模块，默认情况下统统打包进一个文件（bundle.js），这种all in JS 的方式我非常喜欢。但是同时也带来了一些问题，随着静态资源以及模块的增多，bundle.js会变的臃肿不堪，这就导致编译时间会大幅度上升，在使用热更新的情况下，甚至我们改动了一行代码都要重新编译一遍，等待时间可达到几十秒，这对我们的开发体验是非常不利的。同时，对于单页应用来说，所有的资源都在首屏时加载，会拖慢我们应用的首屏时间，导致用户体验变差。显然这种方式是十分粗暴的，因此需要进行合理的优化，以下是我近两天采用的一些方法。 1.抽离公共代码块 对于常用的类库或者common代码块来说，基本上我们不会修改到，因此我们可以把这一部分代码抽离出来，单独打包成一个文件，在入口的html文件当中单独引入。webpack中提供了内置的插件帮我们实现这个功能，例如我们想要将jquery单独打包，可以采用下面这种做法：1234567entry:&#123; path:__dirname+\"/src/entry.js\", vendor:[\"jquery\"] &#125; plugins:[ new webpack.optimize.CommonsChunkPlugin(&#123;name:\"vendor\",filename:\"vendor.js\"&#125;) ] 以上就将jquery单独打包为vendor.js，随后在入口的html文件中引入即可，如下：12&lt; script type=\"text/javascript\" src=\"vendor.js?24f0580a0c65db9f9ddd\"&gt;&lt;/script&gt;&lt; script type=\"text/javascript\" src=\"bundle.js?24f0580a0c65db9f9ddd\"&gt;&lt;/script&gt; 通过以上方式可以有效的提升开发时的体验，抽离出的公共部分不参与打包（热更新的情况下），减少了开发时编译的等待时间。 2.按需加载 对于单页应用，在首屏时加载所有的静态资源是非常低效的，因为并不是所有的模块都会立刻使用到，对于这一类的模块，我们可以在需要的时候加载。如果使用commonjs规范的话，可以使用如下的做法：1234 require.ensure([\"hellojs\"],function()&#123; var hello = require(\"hellojs\"); // and so on &#125;) 这样做在编译过程中会多生成一个文件 x.bundle.js，这个文件就是hello.js对应生成的包，只有当我们需要使用到它时，才会加载，这样就减少了bundle.js的大小，也就是说优化了首屏显示的速度。 3.代码压缩这是一种非常常见的做法，因此不做赘述。在webpack中有内置插件可以使用，推荐在上线时才开启。12345678new webpack.optimize.UglifyJsPlugin(&#123; //代码压缩 compress:&#123; warnings:false, &#125;, output:&#123; comments:false, &#125;, &#125;) 以上便是最近两天所使用的一些方法，当然还有很多可以优化的地方，我也在不断的学习，使用。 参考：https://webpack.github.io/docs/code-splitting.html#commons-chunk","tags":[{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://yoursite.com/tags/JavaScript/"}]},{"title":"个人网站开通啦","date":"2017-02-26T11:38:59.000Z","path":"2017/02/26/个人网站开通啦/","text":"这是一个使用GithubPages+Hexo搭建的个人博客,主题是使用的yilia,在这里先感谢作者的无私分享。今后会在这个网站上更新一下自己学习的经验以及生活上的一些感悟。","tags":[{"name":"生活","slug":"生活","permalink":"http://yoursite.com/tags/生活/"}]}]